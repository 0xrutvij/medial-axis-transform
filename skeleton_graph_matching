import bisect
import itertools
from typing import Dict, List
from modified_skeleton_algorithm import MedialAxisTransformer
import numpy as np
import matplotlib.pyplot as plt
from utils import (
    extract_points_from_file,
    sort_counterclockwise,
    get_shape_paths,
)


def path_distance(puv_r1: np.ndarray, puv_r2: np.ndarray, l1: float, l2: float, weight_factor=30):
    r_diff_sq = np.square(puv_r1 - puv_r2)
    r_sum = puv_r1 + puv_r2

    addend = np.sum(r_diff_sq / r_sum)
    augend = weight_factor * ((l1 - l2) ** 2 / (l1 + l2))
    return addend + augend


def sample_path_for_radii(path_points, radii, path_len, n_samples=20):

    path_pwise_dists = []
    for pt1, pt2 in itertools.pairwise(path_points):
        dist = np.linalg.norm(pt2 - pt1)
        path_pwise_dists.append(round(dist, 6))

    path_dists = np.array(path_pwise_dists).cumsum()

    new_rs = []
    for x in range(n_samples + 1):
        qd = x * (path_len / n_samples)
        ix = bisect.bisect_left(path_dists, qd)
        if qd < 0.00000001:
            new_rs.append(radii[0])
            continue

        diffs = np.flip(abs(path_dists[ix-1:ix+1] - qd))
        rs = radii[ix-1:ix+1]
        contrib = diffs.round(5) * rs
        denom = sum(diffs)
        new_r = contrib.sum() / denom
        new_rs.append(new_r)

    return np.array(new_rs)


def main1():
    input_file1 = "shapes/horse-1.txt"
    input_file2 = "shapes/horse-19.txt"

    points1 = extract_points_from_file(input_file1)
    points2 = extract_points_from_file(input_file2)

    ma_skeleton1 = MedialAxisTransformer.from_boundary_points(points1)
    ma_skeleton2 = MedialAxisTransformer.from_boundary_points(points2)

    adjacency_map1 = ma_skeleton1.skeleton_graph
    end_points1 = ma_skeleton1.skeleton_end_point_indices

    adjacency_map2 = ma_skeleton2.skeleton_graph
    end_points2 = ma_skeleton2.skeleton_end_point_indices

    eps1 = np.array([ma_skeleton1.medial_axis_point_idx_map[i]
                    for i in end_points1])

    eps1 = sort_counterclockwise(eps1)

    plt.scatter(eps1[:, 0], eps1[:, 1])

    for i, label in enumerate(end_points1):
        plt.annotate(str(label), tuple(eps1[i]))

    plt.show()

    # find shortest path between an endpoint and all the points in the graph
    all_ep_pair_sps1 = get_shape_paths(end_points1.copy(), adjacency_map1)
    all_ep_pair_sps2 = get_shape_paths(end_points2.copy(), adjacency_map2)

    # seen_lengths = defaultdict(list)
    # for ep in product(end_points1, end_points1):
    #     _, path = all_ep_pair_sps1[ep]
    #     if len(path) > 1:
    #         seen_lengths[len(path)].append(ep)

    # for ep in product(end_points2, end_points2):
    #     _, path = all_ep_pair_sps2[ep]
    #     if len(path) in seen_lengths:
    #         print(f"This {ep}: {len(path)}")
    #         print(f"Possible matches {seen_lengths[len(path)]}")

    l1, path1 = all_ep_pair_sps1[(13, 40)]
    l2, path2 = all_ep_pair_sps2[(12, 43)]

    r1 = ma_skeleton1.get_radii_vector_along_path(path1)
    r2 = ma_skeleton2.get_radii_vector_along_path(path2)

    print(path_distance(r1, r2, l1, l2))

    # TODO: List
    # (1) Sampling equidistant points along the path
    # (2) path distance matrix
    # (3) optimal subsequence bijection
    # (4) Hungarian algorithm [D ? scipy.optimize.linear_sum_assignment]
    # (5) Sorting points in clockwise direction [D]
    # (6) ?


def main2(f1, f2):
    g_pts, gprime_pts = map(extract_points_from_file, [f1, f2])
    mas1, mas2 = map(MedialAxisTransformer.from_boundary_points, [
                     g_pts, gprime_pts])
    end_points1, end_points2 = mas1.skeleton_end_points, mas2.skeleton_end_points

    fig, ax = plt.subplots(1, 2, sharex=False, sharey=True)
    fig.set_size_inches((12.8, 4.8))

    ax[0].scatter(end_points1[:, 0], end_points1[:, 1], c="b")
    ax[1].scatter(end_points2[:, 0], end_points2[:, 1], c="r")

    for pt in end_points1:
        ax[0].annotate(str(mas1.medial_axis_point_idx_map[tuple(pt)]), pt)

    for pt in end_points2:
        ax[1].annotate(str(mas2.medial_axis_point_idx_map[tuple(pt)]), pt)

    # print([mas1.medial_axis_point_idx_map[tuple(pt)] for pt in end_points1])

    plt.show()

    l1, path1 = mas1.all_pair_eps_shortest_paths[(13, 40)]
    l2, path2 = mas2.all_pair_eps_shortest_paths[(43, 86)]

    r1 = mas1.get_radii_vector_along_path(path1)
    r2 = mas2.get_radii_vector_along_path(path2)

    rn1 = sample_path_for_radii(
        [np.array(mas1.medial_axis_point_idx_map[i]) for i in path1], r1, l1)
    rn2 = sample_path_for_radii(
        [np.array(mas2.medial_axis_point_idx_map[i]) for i in path2], r2, l2)

    # print(path_distance(r1, r2, l1, l2))
    # distance between two similar paths in different horse figs
    print(path_distance(rn1, rn2, l1, l2))


if __name__ == "__main__":
    if1 = "shapes/horse-1.txt"
    if2 = "shapes/horse-19.txt"

    main2(if1, if2)
