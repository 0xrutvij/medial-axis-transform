import bisect
import itertools
from typing import Dict, List

from scipy.optimize import linear_sum_assignment
from modified_skeleton_algorithm import MedialAxisTransformer
import numpy as np
import matplotlib.pyplot as plt
from osb import optimal_subsequence_bijection
from utils import (
    extract_points_from_file,
    sort_counterclockwise,
    get_shape_paths,
)


def optimal_subsequence_bijection(sequence1, sequence2, distances_ps1_ps2):
    pass


def path_distance(puv_r1: np.ndarray, puv_r2: np.ndarray, l1: float, l2: float, weight_factor=30):
    """Distance between two paths"""
    r_diff_sq = np.square(puv_r1 - puv_r2)
    r_sum = puv_r1 + puv_r2

    ratio = r_diff_sq / (r_sum + 0.00000001)
    addend = np.sum(ratio)
    augend = weight_factor * ((l1 - l2) ** 2 / (l1 + l2))
    return addend + augend


def path_distance_matrix(
    vi: int,
    g: MedialAxisTransformer,
    vj_prime: int,
    g_prime: MedialAxisTransformer
) -> np.ndarray:

    if len(g.skeleton_end_points) > len(g_prime.skeleton_end_points):
        g, g_prime = g_prime, g
        vi, vj_prime = vj_prime, vi

    ks = [g.all_pair_eps_shortest_paths[(vi, x)]
          for x in g.skeleton_end_point_indices if x != vi]
    ns = [g_prime.all_pair_eps_shortest_paths[(
        vj_prime, x)] for x in g_prime.skeleton_end_point_indices if x != vj_prime]

    pd_mat = []
    for l_k, path_k in ks:
        pd_mat_row = []
        for l_n, path_n in ns:
            r1 = g.get_radii_vector_along_path(path_k)
            r2 = g_prime.get_radii_vector_along_path(path_n)

            rn1 = sample_path_for_radii(
                [np.array(g.medial_axis_point_idx_map[i]) for i in path_k], r1, l_k)
            rn2 = sample_path_for_radii(
                [np.array(g_prime.medial_axis_point_idx_map[i]) for i in path_n], r2, l_n)

            pd_mat_row.append(round(path_distance(rn1, rn2, l_k, l_n), 2))
        pd_mat.append(pd_mat_row)

    return pd_mat


def sample_path_for_radii(path_points, radii, path_len, n_samples=20):

    path_pwise_dists = []
    for pt1, pt2 in itertools.pairwise(path_points):
        dist = np.linalg.norm(pt2 - pt1)
        path_pwise_dists.append(round(dist, 6))

    path_dists = np.array(path_pwise_dists).cumsum()

    new_rs = []
    for x in range(n_samples + 1):
        qd = x * (path_len / n_samples)
        ix = bisect.bisect_left(path_dists, qd)
        if ix == 0:
            new_rs.append(radii[0])
            continue

        diffs = np.flip(abs(path_dists[ix-1:ix+1] - qd))
        rs = radii[ix-1:ix+1]
        contrib = diffs.round(5) * rs
        denom = sum(diffs)
        new_r = contrib.sum() / denom
        new_rs.append(new_r)

    return np.array(new_rs)


def main1():
    input_file1 = "shapes/horse-1.txt"
    input_file2 = "shapes/horse-19.txt"

    points1 = extract_points_from_file(input_file1)
    points2 = extract_points_from_file(input_file2)

    ma_skeleton1 = MedialAxisTransformer.from_boundary_points(points1)
    ma_skeleton2 = MedialAxisTransformer.from_boundary_points(points2)

    adjacency_map1 = ma_skeleton1.skeleton_graph
    end_points1 = ma_skeleton1.skeleton_end_point_indices

    adjacency_map2 = ma_skeleton2.skeleton_graph
    end_points2 = ma_skeleton2.skeleton_end_point_indices

    eps1 = np.array([ma_skeleton1.medial_axis_point_idx_map[i]
                    for i in end_points1])

    eps1 = sort_counterclockwise(eps1)

    plt.scatter(eps1[:, 0], eps1[:, 1])

    for i, label in enumerate(end_points1):
        plt.annotate(str(label), tuple(eps1[i]))

    plt.show()

    # find shortest path between an endpoint and all the points in the graph
    all_ep_pair_sps1 = get_shape_paths(end_points1.copy(), adjacency_map1)
    all_ep_pair_sps2 = get_shape_paths(end_points2.copy(), adjacency_map2)

    # seen_lengths = defaultdict(list)
    # for ep in product(end_points1, end_points1):
    #     _, path = all_ep_pair_sps1[ep]
    #     if len(path) > 1:
    #         seen_lengths[len(path)].append(ep)

    # for ep in product(end_points2, end_points2):
    #     _, path = all_ep_pair_sps2[ep]
    #     if len(path) in seen_lengths:
    #         print(f"This {ep}: {len(path)}")
    #         print(f"Possible matches {seen_lengths[len(path)]}")

    l1, path1 = all_ep_pair_sps1[(13, 40)]
    l2, path2 = all_ep_pair_sps2[(12, 43)]

    r1 = ma_skeleton1.get_radii_vector_along_path(path1)
    r2 = ma_skeleton2.get_radii_vector_along_path(path2)

    print(path_distance(r1, r2, l1, l2))

    # TODO: List
    # (1) Sampling equidistant points along the path
    # (2) path distance matrix
    # (3) optimal subsequence bijection
    # (4) Hungarian algorithm [D ? scipy.optimize.linear_sum_assignment]
    # (5) Sorting points in clockwise direction [D]
    # (6) ?


def main2(f1, f2):
    g_pts, gprime_pts = map(extract_points_from_file, [f1, f2])
    mas1, mas2 = map(MedialAxisTransformer.from_boundary_points, [
                     g_pts, gprime_pts])
    end_points1, end_points2 = mas1.skeleton_end_points, mas2.skeleton_end_points

    # print([mas1.medial_axis_point_idx_map[tuple(pt)] for pt in end_points1])

    # print(mas1.all_pair_eps_shortest_paths)

    # l1, path1 = mas1.all_pair_eps_shortest_paths[(13, 40)]
    # l2, path2 = mas2.all_pair_eps_shortest_paths[(43, 86)]

    # r1 = mas1.get_radii_vector_along_path(path1)
    # r2 = mas2.get_radii_vector_along_path(path2)

    # rn1 = sample_path_for_radii([np.array(mas1.medial_axis_point_idx_map[i]) for i in path1], r1, l1)
    # rn2 = sample_path_for_radii([np.array(mas2.medial_axis_point_idx_map[i]) for i in path2], r2, l2)

    # print(path_distance(r1, r2, l1, l2))
    # distance between two similar paths in different horse figs
    # print(path_distance(rn1, rn2, l1, l2))
    # np.set_printoptions(precision=2)

    corr = []
    for i in mas1.skeleton_end_point_indices:
        corr_row = []
        for j in mas2.skeleton_end_point_indices:
            # print(path_distance_matrix(i, mas1, j, mas2))
            corr_row.append(
                optimal_subsequence_bijection(np.array(path_distance_matrix(i, mas1, j, mas2))))
        corr.append(corr_row)

    _, gp = linear_sum_assignment(np.array(corr))
    pairs = []
    for i, j in enumerate(gp):
        gi = mas1.skeleton_end_point_indices[i]
        gj = mas2.skeleton_end_point_indices[j]
        pairs.append((gi, gj))

    # print(pairs)
    fig, ax = plt.subplots(2, 2, sharex=True, sharey=True)
    fig.set_size_inches((9.6, 7.2))

    ax[0, 0].scatter(end_points1[:, 0], end_points1[:, 1], c="b")
    ax[0, 0].axis('off')
    ax[0, 1].scatter(end_points2[:, 0], end_points2[:, 1], c="r")
    ax[0, 1].axis('off')
    gp1, gp2 = map(np.array, (g_pts, gprime_pts))
    ax[1, 0].scatter(gp1[:, 0], gp1[:, 1])
    ax[1, 0].axis('off')
    ax[1, 1].scatter(gp2[:, 0], gp2[:, 1])
    ax[1, 1].axis('off')

    for pt in end_points1:
        ax[0, 0].annotate(str(mas1.medial_axis_point_idx_map[tuple(pt)]), pt)

    for pt in end_points2:
        ax[0, 1].annotate(str(mas2.medial_axis_point_idx_map[tuple(pt)]), pt)

    plt.suptitle(str(pairs))
    plt.show()


if __name__ == "__main__":
    if1 = "shapes/horse-1.txt"
    if2 = "shapes/horse-19.txt"

    main2(if1, if2)
