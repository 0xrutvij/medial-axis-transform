from collections import defaultdict
import heapq
from itertools import product
from typing import Dict, List, Tuple
from modified_skeleton_algorithm import MedialAxisTransformer
import numpy as np
from scipy.spatial import Delaunay
# import matplotlib.pyplot as plt
from utils import extract_points_from_file


def path_dissimilarity(puv_r1: np.ndarray, puv_r2: np.ndarray, l1: float, l2: float, weight_factor=1):
    r_diff_sq = np.square(puv_r1 - puv_r2)
    r_sum = puv_r1 + puv_r2

    addend = sum(r_diff_sq / r_sum)
    augend = weight_factor * ((l1 - l2) ** 2 / (l1 + l2))
    return addend + augend


def dijkstras_shortest_paths(adjacency_map: Dict[int, Dict], start_point: int):
    distances = {point: (float("inf"), []) for point in adjacency_map.keys()}
    distances[start_point] = [0, [start_point]]

    priority_queue = [(0, start_point, [start_point])]
    heapq.heapify(priority_queue)

    while priority_queue:
        current_dist, current_pt, current_path = heapq.heappop(priority_queue)

        # if we have already reached a point via a shorter path, skip it
        if current_dist > distances[current_pt][0]:
            continue

        neighbors = adjacency_map[current_pt]

        for neighbor, ndist in neighbors.items():
            dist = current_dist + ndist
            path = current_path + [neighbor]

            # if this route is shorter than any previous routes, add it
            if dist < distances[neighbor][0]:
                distances[neighbor] = (dist, path)
                heapq.heappush(priority_queue, (dist, neighbor, path))

    return distances


def get_shape_paths(endpoints: List, graph: Dict[int, Dict]) -> Dict[Tuple, Tuple[int, List]]:
    all_pairs_end_points_distances = {key: float(
        "inf") if key[0] != key[1] else (0, []) for key in product(endpoints, endpoints)}
    ep_set = set(endpoints)

    while endpoints and any([dist == float("inf") for dist in all_pairs_end_points_distances.values()]):
        ep = endpoints.pop()
        shortest_paths = dijkstras_shortest_paths(graph, ep)

        for pt, dist_path in [item for item in shortest_paths.items() if item[0] in ep_set]:
            dist, path = dist_path
            all_pairs_end_points_distances[(ep, pt)] = (dist, path)
            all_pairs_end_points_distances[(pt, ep)] = (
                dist, list(reversed(path)))

    return all_pairs_end_points_distances


if __name__ == "__main__":
    input_file1 = "shapes/horse-1.txt"
    input_file2 = "shapes/horse-19.txt"

    points1 = extract_points_from_file(input_file1)
    points2 = extract_points_from_file(input_file2)

    ma_skeleton1 = MedialAxisTransformer.from_boundary_points(points1)
    ma_skeleton2 = MedialAxisTransformer.from_boundary_points(points2)

    adjacency_map1 = ma_skeleton1.skeleton_graph
    end_points1 = ma_skeleton1.skeleton_end_point_indices

    adjacency_map2 = ma_skeleton2.skeleton_graph
    end_points2 = ma_skeleton2.skeleton_end_point_indices

    print(end_points1)
    print(end_points2)

    # find shortest path between an endpoint and all the points in the graph
    all_ep_pair_sps1 = get_shape_paths(end_points1.copy(), adjacency_map1)
    all_ep_pair_sps2 = get_shape_paths(end_points2.copy(), adjacency_map2)

    # seen_lengths = defaultdict(list)
    # for ep in product(end_points1, end_points1):
    #     _, path = all_ep_pair_sps1[ep]
    #     if len(path) > 1:
    #         seen_lengths[len(path)].append(ep)

    # for ep in product(end_points2, end_points2):
    #     _, path = all_ep_pair_sps2[ep]
    #     if len(path) in seen_lengths:
    #         print(f"This {ep}: {len(path)}")
    #         print(f"Possible matches {seen_lengths[len(path)]}")

    l1, path1 = all_ep_pair_sps1[(13, 40)]
    l2, path2 = all_ep_pair_sps2[(12, 43)]

    r1 = ma_skeleton1.get_radii_vector_along_path(path1)
    r2 = ma_skeleton2.get_radii_vector_along_path(path2)

    print(path_dissimilarity(r1, r2, l1, l2))
